# This file is autogenerated. Do not edit it by hand. Regenerate it with:
#   srb rbi gems

# typed: true
#
# If you would like to make changes to this file, great! Please create the gem's shim here:
#
#   https://github.com/sorbet/sorbet-typed/new/master?filename=lib/sexp_processor/all/sexp_processor.rbi
#
# sexp_processor-4.17.3

class Sexp < Array
  def /(pattern); end
  def ==(obj); end
  def =~(pattern); end
  def _concat(*arg0); end
  def array_type?; end
  def comments; end
  def comments=(arg0); end
  def compact; end
  def deep_each(&block); end
  def depth; end
  def each_of_type(t, &b); end
  def each_sexp; end
  def eql?(o); end
  def file; end
  def file=(arg0); end
  def find_and_replace_all(from, to); end
  def find_node(name, delete = nil); end
  def find_nodes(name); end
  def gsub(pattern, repl); end
  def hash; end
  def head; end
  def initialize(*args); end
  def inspect; end
  def line(n = nil); end
  def line=(arg0); end
  def line_max; end
  def line_max=(arg0); end
  def map(&blk); end
  def mass; end
  def method_missing(meth, delete = nil); end
  def new(*body); end
  def pretty_print(q); end
  def replace_sexp(pattern, &block); end
  def respond_to?(msg, private = nil); end
  def rest(from = nil); end
  def satisfy?(pattern); end
  def search_each(pattern, &block); end
  def self.-(arg); end
  def self._; end
  def self.___; end
  def self.all(*args); end
  def self.any(*args); end
  def self.atom; end
  def self.child(child); end
  def self.from_array(a); end
  def self.include(child); end
  def self.k(klass); end
  def self.m(*values); end
  def self.not?(arg); end
  def self.q(*args); end
  def self.s(*args); end
  def self.t(name); end
  def sexp_body(from = nil); end
  def sexp_body=(v); end
  def sexp_type; end
  def sexp_type=(v); end
  def structure; end
  def sub(pattern, repl); end
  def to_a; end
  def to_s; end
  def value; end
end
class Sexp::Matcher < Sexp
  def &(other); end
  def -@; end
  def /(sexp); end
  def ===(sexp); end
  def =~(sexp); end
  def >>(other); end
  def greedy?; end
  def inspect; end
  def pretty_print(q); end
  def satisfy?(o); end
  def self.match_subs=(o); end
  def self.match_subs?; end
  def self.parse(s); end
  def |(other); end
end
class Sexp::Matcher::Parser
  def initialize(s); end
  def lex(s); end
  def next_token; end
  def parse; end
  def parse_cmd; end
  def parse_list; end
  def parse_sexp; end
  def peek_token; end
  def tokens; end
  def tokens=(arg0); end
end
class Sexp::Wild < Sexp::Matcher
  def inspect; end
  def pretty_print(q); end
  def satisfy?(o); end
end
class Sexp::Remaining < Sexp::Matcher
  def greedy?; end
  def inspect; end
  def pretty_print(q); end
  def satisfy?(o); end
end
class Sexp::Any < Sexp::Matcher
  def ==(o); end
  def initialize(*options); end
  def inspect; end
  def options; end
  def pretty_print(q); end
  def satisfy?(o); end
end
class Sexp::All < Sexp::Matcher
  def ==(o); end
  def initialize(*options); end
  def inspect; end
  def options; end
  def pretty_print(q); end
  def satisfy?(o); end
end
class Sexp::Not < Sexp::Matcher
  def ==(o); end
  def initialize(value); end
  def inspect; end
  def pretty_print(q); end
  def satisfy?(o); end
  def value; end
end
class Sexp::Child < Sexp::Matcher
  def ==(o); end
  def child; end
  def initialize(child); end
  def inspect; end
  def pretty_print(q); end
  def satisfy?(o); end
end
class Sexp::Atom < Sexp::Matcher
  def inspect; end
  def pretty_print(q); end
  def satisfy?(o); end
end
class Sexp::Pattern < Sexp::Matcher
  def ==(o); end
  def eql?(o); end
  def hash; end
  def initialize(pattern); end
  def inspect; end
  def pattern; end
  def pretty_print(q); end
  def satisfy?(o); end
end
class Sexp::Klass < Sexp::Pattern
  def inspect; end
  def pretty_print(q); end
  def satisfy?(o); end
end
class Sexp::Type < Sexp::Matcher
  def ==(o); end
  def initialize(type); end
  def inspect; end
  def pretty_print(q); end
  def satisfy?(o); end
  def sexp_type; end
end
class Sexp::Include < Sexp::Matcher
  def ==(o); end
  def initialize(value); end
  def inspect; end
  def pretty_print(q); end
  def satisfy?(o); end
  def value; end
end
class Sexp::Sibling < Sexp::Matcher
  def ==(o); end
  def distance; end
  def index_matches(pattern, o); end
  def initialize(subject, sibling, distance = nil); end
  def inspect; end
  def pretty_print(q); end
  def satisfy?(o); end
  def sibling; end
  def subject; end
end
class Sexp::MatchCollection < Array
  def /(pattern); end
  def inspect; end
  def pretty_print(q); end
  def to_s; end
end
class Object < BasicObject
  def s(*args, &blk); end
end
class SexpProcessor
end
class SexpProcessor::Environment
end
class SexpInterpreter < SexpProcessor
end
class MethodBasedSexpProcessor < SexpProcessor
end
class SexpProcessorError < StandardError
end
class UnsupportedNodeError < SexpProcessorError
end
class UnknownNodeError < SexpProcessorError
end
class NotEmptyError < SexpProcessorError
end
class SexpTypeError < SexpProcessorError
end
